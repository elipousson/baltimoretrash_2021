---
title: "Trash related service requests and ECB citations"
output: html_document
params:
  area_name: ["Ellwood Park/Monument"]  #, "Baltimore Highlands"
  area_type: "neighborhood"
  year_start: 2016
  # If union is TRUE, the union_name is required
  union: FALSE # TRUE
  union_name: NULL
  # Map parameters
  asp: "9:6.25" # "17:11"  # "3:2"  # "16:9"
  diag_ratio: 0.08
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)

library(sf)
library(mapbaltimore)
library(ggplot2)
library(dplyr)
library(stringr)
library(lubridate)
library(patchwork)
library(gt)

# Set default theme
theme_set(theme_minimal())
```

# Background

## Area

```{r get_area}
# Get an sf object with all neighborhoods unioned into a single area
area <- get_area(params$area_type,
                 params$area_name,
                 union = params$union)

nearby_areas <- get_nearby_areas(area, type = params$area_type)

if (params$union) {
  area$name <- params$union_name

# Get an sf object with no union
  area_not_union <-
  get_area(
    params$area_type,
    params$area_name,
    union = FALSE)
}

area_layer <- geom_sf(data = area, fill = NA, color = "black", linetype = "dashed")

```

```{r map_area}
area_boundary_color <- "purple"

area_map <- ggplot() +
  layer_area_data(area = area, data = parks, fill = "forestgreen", alpha = 0.8) +
  layer_area_streets(area = area, color = "gray85") +
  layer_area_streets(area = area, sha_class = "all") +
  geom_sf(data = area, color = area_boundary_color, fill = NA) +
  theme_void() +
  labs(
    title = params$area_name
  )

city_map <- ggplot() +
  geom_sf(data = baltimore_city, fill = "white") +
  geom_sf(data = neighborhoods, fill = NA, color = "gray90", size = 0.4) +
  geom_sf(data = area, fill = area_boundary_color, color = area_boundary_color) +
  geom_sf(data = baltimore_city, size = 1.25, color = "black", fill = NA) +
  theme_void()

area_map +
  inset_element(city_map, 0.7, 0, 1, 0.3)
```

## Data on trash

- 311 service requests
- ECB citations

### Get selected requests

```{r get_requests}

# Define list of trash-related request types
select_request_types <-
  c(
    "HCD-Sanitation Property",
    "HCD-Illegal Dumping",
    "SW-Dirty Street",
    "SW-Dirty Alley" #,
    # Exclude request types with few requests
    #"SW-Municipal Trash Can Concern",
    #"SW-Municipal Trash Can Stolen/Lost",
    #"SW-Public (Corner) Trash Can Issue",
    #"SW-Public (Corner) Trash Can Request/Removal",
    #"SW-Trash Can/Recycling Container Complaint",
    #"SW-Park Cans"
  )

months_prior <- 6

# Get 2021 requests of each type
requests <-
  purrr::map_dfr(
    select_request_types,
    ~ get_area_requests(
      area = bind_rows(area, nearby_areas),
      year = 2021,
      request_type = .x,
      trim = TRUE
    )
  ) %>% 
  filter(
    # Filter to requests created in past 6 months
    created_date >= (lubridate::ymd(Sys.Date()) - lubridate::dmonths(months_prior))
  ) %>% 
  mutate(
    # Remove agency prefix for service request type 
    sr_type = str_remove(sr_type, "(HCD-)|(SW-)") 
  )


# Filtering requests by attribute only works if the area type is neighborhood, council district, or police district
if (params$area_type == "neighborhood") {
  requests <- requests %>%
    filter(neighborhood %in% c(params$area_name, nearby_areas$name))

  area_requests <- requests %>%
    filter(neighborhood %in% params$area_name)

  nearby_area_requests <- requests %>%
    filter(neighborhood %in% nearby_areas$name)
} else if (params$area_type == "council district") {
  requests <- requests %>%
    filter(council_district %in% c(params$area_name, nearby_areas$name))

  area_requests <- requests %>%
    filter(council_district %in% params$area_name)

  nearby_area_requests <- requests %>%
    filter(council_district %in% nearby_areas$name)
} else if (params$area_type == "police district") {
  requests <- requests %>%
    filter(police_district %in% c(params$area_name, nearby_areas$name))

  area_requests <- requests %>%
    filter(police_district %in% params$area_name)

  nearby_area_requests <- requests %>%
    filter(police_district %in% nearby_areas$name)
}

```

### Get selected citations

```{r get_citations}
if (params$area_type %in% c("neighborhood", "council district", "police district")) {
  citations <-
    purrr::map_dfr(
      c(params$area_name, nearby_areas$name),
      ~ get_area_citations(
        area_type = params$area_type,
        area_name = .x,
        description = "TRASH"
      )
    )

  citations <- citations %>%
    filter(
      year(violation_date) >= params$year_start
    ) %>%
    # Pull street number (address), block number, and street name from location
    mutate(
      street_number = readr::parse_number(violation_location),
      block_number = floor(street_number / 100) * 100,
      street_name = str_trim(str_remove(violation_location, glue::glue("^{street_number}|^0{street_number}"))),
      citation_status = case_when(
        citation_status == "A" ~ "Appealed",
        citation_status == "O" ~ "Open",
        citation_status == "P" ~ "Paid",
        citation_status == "V" ~ "Voided" # TODO: Should voided citations be excluded?
      )
    )
  
  # TODO: Decide if limiting citation data to last 6 months (or 12 months) is helpful in simplifying the analysis or presentation of the analysis
  recent_citations <- citations %>%
    filter(
      violation_date >= (lubridate::ymd(Sys.Date()) - lubridate::dmonths(months_prior))
    )
}

if (params$area_type == "neighborhood") {
  area_citations <- citations %>%
    filter(neighborhood %in% params$area_name)

  nearby_citations <- citations %>%
    filter(neighborhood %in% nearby_areas$name)
} else if (params$area_type == "council district") {
  area_citations <- citations %>%
    filter(council_district %in% params$area_name)

  nearby_citations <- citations %>%
    filter(council_district %in% nearby_areas$name)
} else if (params$area_type == "police district") {
  area_citations <- citations %>%
    filter(police_district %in% params$area_name)

  nearby_citations <- citations %>%
    filter(police_district %in% nearby_areas$name)
}

citations <- citations %>% 
  mutate(
    nearby = if_else(
      citation_no %in% nearby_citations$citation_no,
      as.character(knitr::combine_words(area$name))
      )
  )
      

citations_source <- "Source: Environmental Control Board (ECB) Citations/Open Baltimore"

```

# Where is trash an issue in the area?

- Requests
  - Map of requests
- Citations
  - Citations by block
  - Citations by block number and street name

## Requests

```{r request_table}
# Rank of requests in area
requests %>% 
  sf::st_drop_geometry() %>% 
  mutate(
    nearby = if_else(
      service_request_num %in% nearby_area_requests$service_request_num,
      "Nearby areas",
      as.character(knitr::combine_words(area$name))
      )
    ) %>% 
  select(nearby, sr_type, sr_status, outcome, days_to_close) %>% 
  gtsummary::tbl_summary(
    by = "nearby",
    label = list(
      sr_type = "Request type",
      sr_status = "Current status",
      outcome = "Request outcome", # TODO: Request outcome data is messy
      days_to_close = "Days to close request"
    )
  ) %>% 
  gtsummary::as_gt() %>% 
  tab_source_note(
    source_note = glue::glue("Nearby areas include {knitr::combine_words(nearby_areas$name)}.")
  ) %>% 
  tab_header(
    title = glue::glue("Service requests in {knitr::combine_words(area$name)} and nearby areas")
  )
```

```{r map_requests}
area_requests %>% 
  ggplot() +
  geom_sf(aes(color = sr_type)) +
  geom_sf(data = area, fill = NA, color = "black", linetype = "dashed") +
  theme_void()

area_requests %>% 
  ggplot() +
  geom_sf(aes(color = days_to_close), alpha = 0.6) +
  area_layer +
  labs(
    color = "Days to close"
  ) +
  scale_color_viridis_c() +
  theme_void()
```

## Citations

```{r plot_citations_by_status_nearby}
citations %>%
  st_drop_geometry() %>% 
  count(nearby, citation_status, sort = TRUE) %>% 
  ggplot() +
  geom_col(aes(x = reorder(citation_status, n), y = n, fill = citation_status)) +
  coord_flip() +
  facet_wrap(~nearby)
```

```{r map_citations}
citations %>% 
  ggplot() +
  geom_sf(aes(color = description), alpha = 0.75) +
  area_layer +
  theme_void() +
  labs(caption = citations_source) +
  set_map_limits(area = area, dist = 25)

```

## Citations by block

```{r citation_block}
#How to organize this graph in descending order? 
citations %>%
  ggplot() +
  geom_bar(aes(x = as.factor(block))) +
  coord_flip() +
  theme(axis.text.y = element_text(size = 5)) +
  ggtitle("Citations per Block") +
  xlab("Block") +
  ylab("Total Citations")
    

library(WVPlots)
citations %>%
  ClevelandDotPlot("block", sort = 1, title = "Citations per block") +
  coord_flip() +
  theme(axis.text.y = element_text(size = 5))
```

```{r citation_type}
citations %>%
  ggplot() +
  geom_bar(aes(x = as.factor(block), fill = description)) +
  coord_flip() +
  theme(axis.text.y = element_text(size = 5)) +
  ggtitle("Citation Types per Block") +
  xlab("Block") +
  ylab("Total Citations")
```

```{r citations_by_block_table}
citations %>%
  st_drop_geometry() %>%
  count(block, name = "citations", sort = TRUE) %>%
  gt()
```

### Plot citations by block number and street

```{r plot_block_number_street}
# FIXME: Figure out a reproducible way for distinguishing between groups of streets
ns_street_cutoff <- 500 # Block number equal or less than this are in the NS group
ew_street_cutoff <- 500 # Block numbers greater than this are in the EW group

block_street_count <- citations |>
  sf::st_drop_geometry() |>
  count(street_name, block_number, name = "count", sort = TRUE) |>
  relocate(block_number, .before = street_name)

plot_block_street <- function(df, highlight_n = 10) {
  df |>
  ggplot() +
  geom_point(aes(x = count, y = block_number), size = 3, alpha = 0.85, color = "purple") +
  facet_wrap(~ street_name) +
  gghighlight::gghighlight(count > highlight_n)
}

ns_streets <-
  block_street_count |>
  filter(block_number <= ns_street_cutoff) |> # Limit plot to N-S streets
  plot_block_street()

ew_streets <-
  block_street_count |>
  filter(block_number > ew_street_cutoff) |> # Limit plot to E-W streets
  plot_block_street()

ns_streets + ew_streets
```

```{r table_block_number_street}
block_street_count |>
  slice_head(n = 10) |>
  gt() |>
  tab_header(
    title = glue::glue("10 blocks in {knitr::combine_words(params$area_name)} with most citations since {params$year_start}")
  ) |>
  cols_label(
    block_number = "Block",
    street_name = "Street",
    count = "Citations"
  ) |>
  tab_source_note(
    citations_source
  )
```

# How are citations addressing the issue of trash in this area?

- Citation status
  - Citation status map
    -Does the map show any cluster(s) where citations are voided or appealed?
- Citations over time
- Total paid per citation map
  - Should the average amount paid per type of citation be found?

### Citation status 

```{r citations_status}
#plots the total number of citations per status
citations %>%
  ggplot() +
  geom_bar(aes(x = citation_status, fill = description)) +
  ggtitle("Citation Status") +
  ylab("Total Citations")
```

```{r citation_status_table}
citations %>%
  st_drop_geometry() %>%
  count(citation_status, name = "citations") %>%
  gt()
```

```{r citation_status_by_block}
#plots the number of citations per block while breaking them down into their status
citations %>%
  ggplot() +
  geom_bar(aes(x = as.factor(block), fill = citation_status)) +
  coord_flip() +
  theme(axis.text.y = element_text(size = 5)) + 
  ggtitle("Citation Status per Block") +
  xlab("Block") + 
  ylab("Citation Status")
```

```{r citation_status_map}
#creates a map that shows the location of each citation based on their status
citations %>% 
  ggplot() +
  geom_sf(aes(color = citation_status)) +
  geom_sf(data = area, fill = NA, color = "black", linetype = "dashed") +
  theme_void() +
  labs(caption = citations_source)
```

### Citations over time

```{r total_citations_over_time}
#review this graph (binwidth)
citations_over_time <- citations %>%
  ggplot() +
  geom_freqpoly(aes(x = violation_date)) +
 # labs(caption = citations_source) +
  ggtitle("Citations over Time") +
  xlab("Date") + 
  ylab("Total Citations")

plotly::ggplotly(citations_over_time)
```

```{r citation_status_over_time}
# review this graph - Different way to plot this out? Maybe 4 line graphs?
citations %>% 
  ggplot() +
  geom_freqpoly(aes(x = violation_date, color = citation_status)) +
  labs(caption = citations_source) +
  ggtitle("Citation Status over Time") +
  xlab("Date") + 
  ylab("Total Citations")
```

### Total paid per citation

```{r total_paid_map}
#maps out the total paid per citation
citations %>%
  ggplot() +
  geom_sf(aes(color = total_paid)) +
  geom_sf(data = area, fill = NA, color = "black", linetype = "dashed") +
  theme_void() +
  scale_color_viridis_c() +
  labs(caption = citations_source)
```
# How area service requests addressing the issue of trash in this area?

-Service requests
  - What is the avg number of days it takes to close each type of request?
-Service requests over time
-Service requests status

```{r plot_requests}
#Change tittle? 
#plots the number of days it takes for each service request to be closed
requests %>% 
  ggplot(aes(x = days_to_close, y = sr_type, color = sr_type), alpha = 0.6) +
  geom_point() +
  theme_minimal() + 
  ggtitle("Service Requests Closure Time") +
  xlab("Days to Close") + 
  ylab("Request Type")
```

```{r request_table}
#creates a table to summarize the total number of each type of service request
requests %>%
  st_drop_geometry() %>% 
  count(sr_type, name = "requests", sort = TRUE) %>% 
  gt()
```
```{r request_over_time}
#plots the number of requests that were created per (day?) for each type of request
requests %>%
  ggplot() +
  geom_freqpoly(aes(x = created_date, color = sr_type)) +
  ggtitle("Requests over Time") +
  xlab("Date") +
  ylab("Total Requests")
```
```{r request_status_table}
#creates a table of the status for all requests
requests %>%
  st_drop_geometry() %>% 
  count(sr_status, name = "requests", sort = TRUE) %>% 
  gt()
```



